% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tibble.R
\name{tibble}
\alias{tibble}
\alias{tbl_df}
\alias{tbl_df-class}
\title{Build a data frame}
\usage{
tibble(..., .rows = NULL, .name_repair = c("check_unique", "unique",
  "syntactic", "minimal"))
}
\arguments{
\item{...}{A set of name-value pairs. Arguments are evaluated sequentially,
so you can refer to previously created elements. These arguments are
processed with \code{\link[rlang:quos]{rlang::quos()}} and support unquote via \code{!!} and
unquote-splice via \code{\link{!!!}}.}

\item{.rows}{The number of rows, useful to create a 0-column tibble or
just as an additional check.}

\item{.name_repair}{Treatment of problematic column names:
\itemize{
\item \code{"minimal"}: No name repair or checks, beyond basic existence,
\item \code{"unique"}: Make sure names are unique and not empty,
\item \code{"check_unique"}: (default value), no name repair, but check they are \code{unique},
\item \code{"syntactic"}: Make the names \code{unique} and syntactic
\item a function: apply custom name repair (e.g., \code{.name_repair = make.names}
for names in the style of base R).
\item A purrr-style anonymous function, see \code{\link[=as_function]{as_function()}}
}

See \link{name-repair} for more details on these terms and the strategies used
to enforce them.}
}
\description{
\code{tibble()} constructs a data frame. It is used like \code{\link[base:data.frame]{base::data.frame()}}, but
with a couple notable differences:
\itemize{
\item The returned data frame has the class \code{tbl_df}, in addition to
\code{data.frame}. This allows so-called "tibbles" to exhibit some special
behaviour, such as enhanced printing. Details below.
\item \code{tibble()} is much more passive than \code{\link[base:data.frame]{base::data.frame()}} in terms of
transforming the user's input. Character vectors are not coerced to factor.
Variable names are not modified.
\item \code{tibble()} builds variables sequentially. When defining a variable,
you can refer to variables created earlier in the call.
}
}
\section{tibbles vs. data frames}{


Text is currently just taken from old description
\itemize{
\item Never coerces inputs (i.e. strings stay as strings!).
\item Never adds \code{row.names}.
\item Only recycles length 1 inputs.
\item Automatically adds column names.
\item Doesn't munge column names.
\item Evaluates its arguments lazily and in order.
\item Adds \code{tbl_df} class to output.
}
}

\examples{
# Unnamed arguments are named with their expression:
a <- 1:5
tibble(a, a * 2)

# Scalars (vectors of length one) are recycled:
tibble(a, b = a * 2, c = 1)

# Columns are available in subsequent expressions:
tibble(x = runif(10), y = x * 2)

# tibble() never coerces its inputs,
str(tibble(letters))
str(tibble(x = list(diag(1), diag(2))))

# or munges column names (unless requested),
tibble(`a + b` = 1:5)

# but it forces you to take charge of names, if they need repair:
try(tibble(x = 1, x = 2))
tibble(x = 1, x = 2, .name_repair = "unique")
tibble(x = 1, x = 2, .name_repair = "minimal")

## By default, non-syntactic names are allowed,
df <- tibble(`a 1` = 1, `a 2` = 2)
## because you can still index by name:
df[["a 1"]]
df$`a 1`
with(df, `a 1`)

## Syntactic names are easier to work with, though, and you can request them:
df <- tibble(`a 1` = 1, `a 2` = 2, .name_repair = "syntactic")
df$a.1

## You can specify your own name repair function:
tibble(x = 1, x = 2, .name_repair = make.unique)

tibble(x = 1, x = 2, .name_repair = ~make.names(., unique = TRUE))

fix_names <- function(x) gsub("\\\\s+", "_", x)
tibble(`year 1` = 1, `year 2` = 2, .name_repair = fix_names)

# Tibbles can contain columns that are tibbles or matrices
# if the number of rows is consistent:
tibble(
  a = 1:3,
  b = tibble(
    c = 4:6,
    d = 7:9
  ),
  e = tibble(
    f = tibble(
      g = letters[1:3]
    )
  )
)
tibble(
  a = 1:4,
  b = diag(4),
  c = cov(iris[1:4])
)

# data can not contain POSIXlt columns, or tibbles or matrices
# with inconsistent number of rows:
try(tibble(y = strptime("2000/01/01", "\%x")))
try(tibble(a = 1:3, b = tibble(c = 4:7)))

# You can splice-unquote a list of quosures and expressions:
tibble(!!!list(x = rlang::quo(1:10), y = quote(x * 2)))

}
\seealso{
\code{\link[=as_tibble]{as_tibble()}} to turn an existing list into a data frame,
\link{name-repair} for more detail on name repair.
}
